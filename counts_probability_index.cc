/*
 * @file counts_probability_index.cc
 * @author Melissa Ip
 *
 * This parses a simulation file, where the first column represents
 * the index of the trio in the reference TrioVector at 4x coverage, the
 * second column represents the number of random trios that have a mutation,
 * and the third column represents the number of random trios that do not have
 * a mutation. The rowwise sum of the second and third column is the total
 * number of random trios that match the key trio (given its index in the first
 * column). This file is generated by simulation_driver.cc when running
 * multiple jobs in parallel and will have more than one set of counts for
 * each trio index. Thus, this keeps track of all data by index.
 *
 * This calculates the empirical probability for each trio using the following
 * formula:
 *
 * P(mutation|trio) = #trios with mutation / #total trios
 *
 * The probabilities should match the probabilities from the result of
 * MutationProbability from simulation_trio.cc. This prints the probability
 * for each trio on a new line.
 *
 * To compile on Herschel:
 * c++ -std=c++11 -L/usr/local/lib -I/usr/local/include -o counts_probability_index utility.cc counts_probability_index.cc
 *
 * To run this file, provide the following command line inputs:
 * ./counts_probability_index <input>.txt <output>.txt
 */
#include <fstream>
#include <sstream>

#include "utility.h"


int main(int argc, const char *argv[]) {
  if (argc < 3) {
    Die("USAGE: counts_probability_index <input>.txt <output>.txt");
  }

  const string file_name = argv[1];
  ifstream fin(file_name);
  if (!fin.is_open() || 0 != fin.fail()) {
    Die("Input file cannot be read.");
  }

  const string fout_name = argv[2];
  ofstream fout(fout_name);

  double probability = 0.0;
  vector<double> probabilities;
  int index = 0;
  int has_mutation_total = 0;
  int has_no_mutation_total = 0;
  int total_trios = 0;
  int has_mutation_totals[kTrioCount] = {0};
  int trio_totals[kTrioCount] = {0};
  string line;

  while (getline(fin, line)) {
    line.erase(remove(line.begin(), line.end(), '\n'), line.end());
    stringstream str(line);
    str >> index;
    str >> has_mutation_total;
    str >> has_no_mutation_total;
    total_trios = has_mutation_total + has_no_mutation_total;
    has_mutation_totals[index] += has_mutation_total;
    trio_totals[index] += total_trios;
  }
  fin.close();

  for (int i = 0; i < kTrioCount; ++i) {
    if (has_mutation_totals[i] == 0) {
      probability = 0.0;
    } else {
      probability = (double) has_mutation_totals[i] / trio_totals[i];
    }
    probabilities.push_back(probability);
  }

  ostream_iterator<double> output_iter(fout, "\n");
  copy(probabilities.begin(), probabilities.end(), output_iter);
  fout.close();

  return 0;
}
